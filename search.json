[{"title":"010Editor破解(0xac注册算法分析)","date":"2021-11-10T02:22:34.000Z","url":"/2021/11/09/010Editor/","tags":[["PE64","/tags/PE64/"],["ida","/tags/ida/"],["assembly","/tags/assembly/"]],"categories":[["逆向","/categories/%E9%80%86%E5%90%91/"]],"content":" 近期多次用到了010Editor的文件模板功能，想到自己还是在虚拟机里用大佬patch的老版本，遂决定自己尝试动手分析破解（被毒打）。 准备阶段 010Editor v12.0.1 portable Vida 7.5 逆向分析010Editor没有加壳，直接上ida。 寻找关键函数在010Editor中以随意写的用户名和注册码注册，反馈如下： 尝试在ida中搜索Invalid name 居然直接就找到了，SWEETSCAPE没有走心啊。 Ctrl+X定位到引用该字符串的代码处，F5查看。很简单的在上边不远找到了成功注册的代码： 初步分析相关函数这里要求v17==219，定位到对应汇编码 汇编代码对应了%edi与0xDB比较不妨对loc_7FF628EF5595Ctrl+X往上走，可以看到有两个相距不远的引用 在这里sub_7FF628D084F4的返回值对%edi做了赋值，跟进去看看函数的汇编码不算长，不过ida当然是要上效率神器F5的简单清晰的看到了要找的返回值219，抓住主要矛盾，跟进sub_7FF628D06118，我们希望ta返回45 这里的函数内容相对复杂(需要动态调试逐步尝试)，进入了注册码的验证环节，我贴一下主要部分对于输入的注册码为123456789ABCDEFF的情况,sub_7FF628D06118会将字符串转化成hex使用。 根据r[3]的不同，注册码分为三个版本：0x9c,0xfc,0xac 0x9c Evaluation Key: 8byte长的测试key，经测试可以使用但已不再受官方服务支持,这里不做分析（推荐大佬余生挚爱传奇的文章，对r[3]=0x9c的key做了详实的分析）。 0xfc VersionLicense Key: 版本key，不返回我们需要的值45，故不作分析。0xac TimeLicense Key: key中包含了与有效时间关联的byte，r[4]~r[7]与用户名进行了验证。 关键代码如下 注册算法详解对注册算法做一点分析，基于idaF5处理后的代码，主要关注函数sub_7FF628D06118中的各类条件语句，令其返回注册成功需要的值。 第一处if语句：对两个地址的值是否为0做判断，我们需要此次为1。第一处地址：第二处地址：很明显两个指针分别指向了两个结构体中字符串的长度，只要保持输入非空即可。 第二处if语句：嵌套了一个do{}while()循环，将用户名与特点字符做比较和处理，没有影响，可以无视。 switch语句：将注册码的hex值赋值后，对r[3]进行switch分支，对应了上边0x9c,0xfc,0xac，三个注册码版本，此次r[3]为0xac。照例只关注if语句，unsiged int v23的取值区间应在[0x1，0x3e7].为v23赋值的函数对应的python代码如下: 在后续的算法中,v23的值代表注册码的可使用次数.(也就是说存在在线验证) 跳转至LABEL_26:0xac版本的key还有最后两处if. 第一处:v25的值与输入的用户名进行验证,要求满足: v25 &amp; 0xff == r[4](v25&gt;&gt;8) &amp; 0xff == r[5](v25&gt;&gt;16) &amp; 0xff == r[6](v25&gt;&gt;24) &amp; 0xff == r[7]注册机的编写思路就需要反着来,先基于用户名生成r[4]~r[7],再反推其他r[?]值. 第二处:要求v29&gt;=0x49c7,为v29赋值的函数对应的python代码如下: 在后续算法中,v29*86400实际上得到了一个时间戳,要求大于0x49c7意味着到期时间要在2021年9月17日之后.推测这应该是安装时写入的一个值. 基于上文,给出注册机关键代码： 注册机生成通过上面的分析，可以实现一个简单的注册机对010Editor注册。 总结010Editor可以算是对逆向新手比较友好了,算法复杂度有限,没有各种或经典的或自定义的保护机制,非常适合入门选手尝试patch一番."}]